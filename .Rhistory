allTerms <- Terms
errorterm <- attr(Terms, "variables")[[1L + indError]]
intercept <- attr(Terms, "intercept")
ecall <- lmcall
ecall$formula <- as.formula(paste(deparseb(formula[[2L]]),
"~", deparseb(errorterm[[2L]]), if (!intercept)
"- 1"), env = environment(formula))
ecall$method <- "qr"
ecall$qr <- TRUE
ecall$contrasts <- NULL
er.fit <- eval(ecall, parent.frame())
options(opcons)
nmstrata <- attr(terms(er.fit), "term.labels")
nmstrata <- sub("^`(.*)`$", "\\1", nmstrata)
nmstrata <- c("(Intercept)", nmstrata)
qr.e <- er.fit$qr
rank.e <- er.fit$rank
if (rank.e < NROW(er.fit$coefficients))
warning("Error() model is singular")
qty <- er.fit$residuals
maov <- is.matrix(qty)
asgn.e <- er.fit$assign[qr.e$pivot[1L:rank.e]]
maxasgn <- length(nmstrata) - 1L
nobs <- NROW(qty)
len <- if (nobs > rank.e) {
asgn.e[(rank.e + 1L):nobs] <- maxasgn + 1L
nmstrata <- c(nmstrata, "Within")
maxasgn + 2L
}
else maxasgn + 1L
result <- setNames(vector("list", len), nmstrata)
lmcall$formula <- form <- update(formula, paste(". ~ .-",
deparseb(errorterm)))
Terms <- terms(form)
lmcall$method <- "model.frame"
mf <- eval(lmcall, parent.frame())
xlev <- .getXlevels(Terms, mf)
resp <- model.response(mf)
qtx <- model.matrix(Terms, mf, contrasts)
cons <- attr(qtx, "contrasts")
dnx <- colnames(qtx)
asgn.t <- attr(qtx, "assign")
if (length(wts <- model.weights(mf))) {
wts <- sqrt(wts)
resp <- resp * wts
qtx <- qtx * wts
}
qty <- as.matrix(qr.qty(qr.e, resp))
if ((nc <- ncol(qty)) > 1L) {
dny <- colnames(resp)
if (is.null(dny))
dny <- paste0("Y", 1L:nc)
dimnames(qty) <- list(seq(nrow(qty)), dny)
}
else dimnames(qty) <- list(seq(nrow(qty)), NULL)
qtx <- qr.qty(qr.e, qtx)
dimnames(qtx) <- list(seq(nrow(qtx)), dnx)
for (i in seq_along(nmstrata)) {
select <- asgn.e == (i - 1L)
ni <- sum(select)
if (!ni)
next
xi <- qtx[select, , drop = FALSE]
cols <- colSums(xi^2) > 1e-05
if (any(cols)) {
xi <- xi[, cols, drop = FALSE]
attr(xi, "assign") <- asgn.t[cols]
fiti <- lm.fit(xi, qty[select, , drop = FALSE])
fiti$terms <- Terms
}
else {
y <- qty[select, , drop = FALSE]
fiti <- list(coefficients = numeric(), residuals = y,
fitted.values = 0 * y, weights = wts, rank = 0L,
df.residual = NROW(y))
}
if (projections)
fiti$projections <- proj(fiti)
class(fiti) <- c(if (maov) "maov", "aov", oldClass(er.fit))
result[[i]] <- fiti
}
structure(class = c("aovlist", "listof"), result[!vapply(result,
is.null, NA)], error.qr = if (qr)
qr.e, call = Call, weights = if (length(wts))
wts, terms = allTerms, contrasts = cons, xlevels = xlev)
}
}
# A formula usada no R e alguns outros software é
# ilustrada usando a soma dos quadrados da regressão (SQR)
# e dos erros do modelo (SQE)  R2 = SQR/(SQR+SQE)
# usando uma função para as somas dos quadrados
sq <- function(y,
m='mx')
sum((y - ifelse(m == 'mx',
mean(y),
m))^2)
# A formula usada no R e alguns outros software é
# ilustrada usando a soma dos quadrados da regressão (SQR)
# e dos erros do modelo (SQE)  R2 = SQR/(SQR+SQE)
# usando uma função para as somas dos quadrados
sq <- function(y,
m='mx')
sum((y - ifelse(m == 'mx',
mean(y),
m))^2)
# A formula usada no R e alguns outros software é
# ilustrada usando a soma dos quadrados da regressão (SQR)
# e dos erros do modelo (SQE)  R2 = SQR/(SQR+SQE)
# usando uma função para as somas dos quadrados
sq <- function(y,
m='mx')
library(bpca)
bp=bpca(iris[-4])
bp=bpca(iris[-5])
bp
summary(bp)
plot(bp, var.cex = .4, obj.names = F)
plot(bp, var.factor = .4, obj.names = F)
plot(bp, var.factor = .4, obj.names = F)
plot(bp, var.factor = .4, obj.names = F. obj.col='red')
plot(bp, var.factor = .4, obj.names = F, obj.col='red')
plot(bp, var.factor = .4, obj.names = F, obj.col='blue')
1+1
3+2
sqrt(9)
1+1
sd
var
iris
iris3
1+1
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debug(TukeyC.default)
methods(TukeyC)
debug(TukeyC)
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
undebug(summary)
undebug(TukeyC)
undebug(aov)
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
debug(aov)
debugSource('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
undebug(aov)
debug(TukeyC)
source('C:/Users/jcfaria/Dropbox/cursos/R/anova_dic_bal.R')
source('C:/Users/jcfaria/Desktop/R-debug/palindrome.R')
debugSource('C:/Users/jcfaria/Desktop/R-debug/palindrome.R')
str(debugSource)
str(source)
str(debugSource)
source('C:/Users/jcfaria/Desktop/R-debug/palindrome.R')
debug(biggest_palindrome)
biggest_palindrome()
undebug(biggest_palindrome)
debug(biggest_palindrome)
biggest_palindrome()
undebug(biggest_palindrome)
source('C:/Users/jcfaria/Desktop/R-debug/palindrome.R')
biggest_palindrome()
debug(biggest_palindrome)
biggest_palindrome()
sd
sd
# Find the largest palindrome that is the product of two 3-digit numbers
biggest_palindrome <- function() {
best <- 0
for (x in 100:999) {
for (y in x:999) {
candidate <- x * y
if (candidate > best && palindrome(candidate)) {
best <- candidate
}
}
}
best
}
source('C:/Users/jcfaria/Desktop/R-debug/palindrome.R')
View(get_digit)
View(biggest_palindrome)
View(palindrome)
View(biggest_palindrome)
View(AIC)
View(biplot)
debug(boxplot)
boxplot(rnorm(1e2))
boxplot(rnorm(1e2))
1+2
# Indicate whether a positive number is a palindrome
palindrome <- function(num) {
browser()
digits <- floor(log(num, 10)) + 1
for (x in 1:((digits %/% 2))) {
digit1 <- get_digit(num, x)
digit2 <- get_digit(num, (digits + 1) - x)
if (digit1 != digit2)
return(FALSE)
}
# browser()
return(TRUE)
}
debug(TukeyC)
source('C:/Users/jcfaria/Dropbox/cursos/R/anova_dbc.R')
source('C:/Users/jcfaria/Dropbox/cursos/R/anova_dbc.R')
source('C:/Users/jcfaria/Dropbox/cursos/R/anova_dbc.R')
source('C:/Users/jcfaria/Dropbox/cursos/R/anova_dbc.R')
debug(TukeyC)
source('C:/Users/jcfaria/Dropbox/cursos/R/anova_dbc.R')
sd
# Indicate whether a positive number is a palindrome
palindrome <- function(num) {
browser()
digits <- floor(log(num, 10)) + 1
for (x in 1:((digits %/% 2))) {
digit1 <- get_digit(num, x)
digit2 <- get_digit(num, (digits + 1) - x)
if (digit1 != digit2)
return(FALSE)
}
# browser()
return(TRUE)
}
1+1
palindrome <- function(num) {
browser()
digits <- floor(log(num, 10)) + 1
for (x in 1:((digits %/% 2))) {
digit1 <- get_digit(num, x)
digit2 <- get_digit(num, (digits + 1) - x)
if (digit1 != digit2)
return(FALSE)
}
# browser()
return(TRUE)
}
source('C:/Users/jcfaria/Desktop/R-debug/palindrome.R')
debug(palindrome)
biggest_palindrome()
biggest_palindrome()
biggest_palindrome()
biggest_palindrome()
biggest_palindrome()
source('C:/Users/jcfaria/Desktop/R-debug/palindrome.R')
biggest_palindrome()
debug(palindrome)
biggest_palindrome()
biggest_palindrome()
biggest_palindrome()
biggest_palindrome()
biggest_palindrome()
biggest_palindrome()
1+2
sd
# Indicate whether a positive number is a palindrome
palindrome <- function(num) {
# browser()
digits <- floor(log(num, 10)) + 1
for (x in 1:((digits %/% 2))) {
digit1 <- get_digit(num, x)
digit2 <- get_digit(num, (digits + 1) - x)
if (digit1 != digit2)
return(FALSE)
}
# browser()
return(TRUE)
}
library(bpca)
library(gexp)
library(gexp)
debug(gexp)
gexp()
library(gexp)
ex1 <- gexp()
debug(gexp)
ex1 <- gexp()
debug(gexp.crd)
ex1 <- gexp()
ex1 <- gexp()
library(data.table)
## Not run:
##D example(data.table)  # to run these examples at the prompt
## End(Not run)
dF = data.frame(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
DT = data.table(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
plot(1:10)
## Not run:
##D example(data.table)  # to run these examples at the prompt
## End(Not run)
dF = data.frame(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
DT = data.table(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
dF
plot(1:20)
library(data.table)
plot(1:10)
plot(1:10)
## Not run:
##D example(data.table)  # to run these examples at the prompt
## End(Not run)
dF = data.frame(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
View(dF)
library(qdap)
debug(dist_tab)
dist_tab(rnorm(1e4), 10)
freqdist
freqdist::freqdist(1e3)
search()
library(fdth)
tb=fdt(iris, by=Species)
tb=fdt(iris, by='Species')
tb
View(tb)
View(dF)
library(TukeyC)
library(fdth)
View(TukeyC)
View(dF)
# Extract nth (from left) digit of a number
get_digit <- function(num, n) {
# remove numbers on left, then numbers on right
(num %% (10 ^ n)) %/% (10 ^ n)
}
# Indicate whether a positive number is a palindrome
palindrome <- function(num) {
# browser()
digits <- floor(log(num, 10)) + 1
for (x in 1:((digits %/% 2))) {
digit1 <- get_digit(num, x)
digit2 <- get_digit(num, (digits + 1) - x)
if (digit1 != digit2)
return(FALSE)
}
# browser()
return(TRUE)
}
# Indicate whether a positive number is a palindrome
palindrome <- function(num) {
# browser()
digits <- floor(log(num, 10)) + 1
for (x in 1:((digits %/% 2))) {
digit1 <- get_digit(num, x)
digit2 <- get_digit(num, (digits + 1) - x)
if (digit1 != digit2)
return(FALSE)
}
# browser()
return(TRUE)
}
# remove numbers on left, then numbers on right
(num %% (10 ^ n)) %/% (10 ^ n)
# Extract nth (from left) digit of a number
get_digit <- function(num, n) {
# remove numbers on left, then numbers on right
(num %% (10 ^ n)) %/% (10 ^ n)
}
# browser()
digits <- floor(log(num, 10)) + 1
# Indicate whether a positive number is a palindrome
palindrome <- function(num) {
# browser()
digits <- floor(log(num, 10)) + 1
for (x in 1:((digits %/% 2))) {
digit1 <- get_digit(num, x)
digit2 <- get_digit(num, (digits + 1) - x)
if (digit1 != digit2)
return(FALSE)
}
# browser()
return(TRUE)
}
# Find the largest palindrome that is the product of two 3-digit numbers
biggest_palindrome <- function() {
best <- 0
# for (x in 100:999) {
#  for (y in x:999) {
for (x in 1:2) {
for (y in x:2) {
candidate <- x * y
if (candidate > best && palindrome(candidate)) {
best <- candidate
}
}
}
best
}
ls()
dF
library(fdth)
tb=make.fdt(1:10, 10, 100)
tb
View(tb)
View(tb[["table"]])
View(iris)
View(airquality)
View(iris)
View(npk)
View(iris)
View(iris)
View(iris)
View(iris)
View(iris)
plot(mtcars)
plot(mtcars)
plot(mtcars)
plot(mtcars)
plot(mtcars)
library(fdth)
tb <- fdt(iris)
plot(tb)
library(fdth)
tb <- fdt(iris)
plot(tb)
summary(tb)
plot(tb)
plot(tb)
plot(tb)
options(device = "windows")
plot(1:10)
windows();(mpg ~ wt, mtcars)
plot(1:10)
options(device = "windows")
plot(rnorm(1e3))
options(device = "windows")
plot(rnorm(1e3))
dev.new()
options(device = "windows")
plot(rnorm(1e3))
options()
options('dev')
options('^dev')
options('device')
options('device')
options(device='windows')
options('device')
plot(1)
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
options('device')
options(device='windows')
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
plot(rnorm(1e3))
dev.new()
dev.new()
x11()
windows()
plot(rnorm(1e3))
dev.new()
plot(1)
plot(rnorm(1e3))
getwd()
setwd('.\GitHub\gexp')
dir()
setwd('.\\GitHub\\gexp')
dir()
library(R.utils)
sourceDirectory('./R')
debug(gexp.fe)
#!. FE - LSD - QT
fe_lsd <- gexp(mu=NULL,
fe=list(f1=c(10,  # Intercepto
5,  # b1*
0,  # b2
0,  # b3
0), # b4
f2=c(2, 3)),
inte=c(1, 15, rep(1, 6)),
rowe=rep(1, 10),
cole=rep(1, 10),
fl=list(tra=ordered(seq(0,
40,
by=10)),
B=paste('b',
1:2,
sep='')),
coll=list(Col=paste('c',
1:10,
sep='')),
rowl=list(Row=paste('r',
1:10,
sep='')),
contrasts=list(tra=contr.poly(5),
B=diag(2),
Col=diag(10),
Row=diag(10)),
type='FE')
resl2
real1
resl1
